**事件一：**

学习了Rust所有权知识；所有权有以下三条规则：

    1、Rust中每个值都有一个变量，称为其所有者

    2、一次只能有一个所有者

    3、当所有者不在程序运行范围内时，该值将被删除。

学习克隆、引用与租借、垂悬引用概念。

**事件二**

学习了Rust Slice（切片）类型；Rust 中的字符串类型实质上记录了字符在内存中的起始位置和其长度，字符串类型有两种常用的：str 和 String，凡是用双引号包括的字符串常量整体的类型性质都是 &str，String比str多一个capacity（容量）属性，String 和 str 都支持切片，切片的结果是 &str 类型的数据，即引用类型,如：

`let slice = &s[0..3]`

**事件三**
学习了结构体（struct）；基本格式是：

`结构体类名 {

    字段名 : 字段值,

    ...

}`

元组结构体：它与元组的区别是它有名字和固定的类型格式。

输出结构体：需要导入调试库#[derive(Debug)]，之后就可以在println!和print宏中使用{:?}占位符输出整个结构体，属性较多时可以使用{:#?}占位符输出整个结构体。

结构体方法：方法与函数相似，只是它用于操作结构体实例，结构体方法的第一个参数必须是&self，但调用不用填写self。

结构体关联函数：这种函数不依赖实例，但使用它需要声明在哪个块中，例如String::from函数就是一个关联函数。它在impl块中没有&self参数。

单元结构体：结构体可以只作为一种象征，无需任何成员，如：`struct UnitStruct`

**事件三**

学习了Rust枚举类；不能像访问结构体字段一样访问枚举类绑定的属性，需要使用match语法。

match语法：可以实现分支结构，match块可以当作函数表达式来对待，可以有返回值，但返回值表达式类型必须一致：

`match 枚举类实例 {

    分类1 => 返回值表达式,

    分类2 => 返回值表达式,

    ...

}`

如果把枚举类附加属性定义成元组，在 match 块中需要临时指定一个名字，match还可以对整数、浮点数、字符和字符串切片引用（&str）类型的数据进行分支选择。但是浮点数类型被分支选择虽然合法，但不推荐这样使用，精度问题可能会导致分支错误。对非枚举类进行分支选择时必须注意处理例外情况，处理例外情况时需要用`_`表示。

**计划**

枚举类还有Option枚举类与 if let语法未学习，明天需要继续加快进度学习完Rust的基本知识，还有多加代码练习。